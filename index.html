<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Boss AI â€“ Visual Automation</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(to right, #000000, #0a0a2a);
      color: #00bfff;
      overflow: hidden;
    }
    .glow { text-shadow: 0 0 5px #00bfff, 0 0 10px #00bfff; }
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
    }
    #toolbar button {
      background: #001f33;
      color: #00bfff;
      border: 1px solid #00bfff;
      padding: 6px 12px;
      margin-right: 8px;
      font-family: 'Orbitron', sans-serif;
      cursor: pointer;
    }
    #canvas {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .node {
      position: absolute;
      width: 180px;
      padding: 10px;
      background: #0c0c0c;
      border: 1px solid #00bfff;
      color: #00bfff;
      cursor: move;
      text-align: center;
    }
    .active { border: 2px solid yellow; }
    .success { border: 2px solid lime; }
    .error { border: 2px solid red; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="addNode('Script Writer')">Script Writer</button>
    <button onclick="addNode('HTML Extract')">HTML Extract</button>
    <button onclick="addNode('Logger')">Logger</button>
    <button onclick="runFlow()">Run</button>
    <button onclick="clearFlow()">Clear</button>
    <button onclick="exportFlow()">Export</button>
    <button onclick="importFlow()">Import</button>
  </div>
  <div id="canvas"></div>

  <script>
    let nodes = [];
    let connections = [];
    let nodeId = 0;

    function addNode(type) {
      const div = document.createElement('div');
      div.className = 'node';
      div.innerText = type + " (ID: " + nodeId + ")";
      div.style.left = Math.random() * 600 + 'px';
      div.style.top = Math.random() * 400 + 'px';
      div.setAttribute('data-id', nodeId);
      div.setAttribute('data-type', type);
      div.onclick = () => {
        const targetId = prompt("Connect to node ID:");
        if (targetId !== null) connections.push([parseInt(div.dataset.id), parseInt(targetId)]);
      };
      makeDraggable(div);
      document.getElementById('canvas').appendChild(div);
      nodes.push({ id: nodeId, type, el: div });
      nodeId++;
    }

    function makeDraggable(el) {
      let offsetX = 0, offsetY = 0, isDown = false;
      el.onmousedown = function(e) {
        isDown = true;
        offsetX = e.offsetX;
        offsetY = e.offsetY;
      };
      document.onmouseup = () => isDown = false;
      document.onmousemove = (e) => {
        if (!isDown) return;
        el.style.left = (e.pageX - offsetX) + 'px';
        el.style.top = (e.pageY - offsetY) + 'px';
      };
    }

    function clearFlow() {
      document.getElementById('canvas').innerHTML = '';
      nodes = [];
      connections = [];
      nodeId = 0;
    }

    function exportFlow() {
      const data = {
        nodes: nodes.map(n => ({ id: n.id, type: n.type, x: n.el.style.left, y: n.el.style.top })),
        connections
      };
      navigator.clipboard.writeText(JSON.stringify(data)).then(() => {
        alert("Flow exported to clipboard!");
      });
    }

    function importFlow() {
      const input = prompt("Paste your flow JSON:");
      if (!input) return;
      const data = JSON.parse(input);
      clearFlow();
      data.nodes.forEach(n => {
        const div = document.createElement('div');
        div.className = 'node';
        div.innerText = n.type + " (ID: " + n.id + ")";
        div.style.left = n.x;
        div.style.top = n.y;
        div.setAttribute('data-id', n.id);
        div.setAttribute('data-type', n.type);
        div.onclick = () => {
          const targetId = prompt("Connect to node ID:");
          if (targetId !== null) connections.push([parseInt(div.dataset.id), parseInt(targetId)]);
        };
        makeDraggable(div);
        document.getElementById('canvas').appendChild(div);
        nodes.push({ id: n.id, type: n.type, el: div });
        nodeId = Math.max(nodeId, n.id + 1);
      });
      connections = data.connections;
    }

    async function runFlow() {
      const context = {};
      const sorted = topologicalSort(nodes.map(n => n.id), connections);
      for (let id of sorted) {
        const node = nodes.find(n => n.id === id);
        if (!node) continue;
        try {
          node.el.classList.remove('success', 'error');
          node.el.classList.add('active');
          await runNode(node, context);
          node.el.classList.remove('active');
          node.el.classList.add('success');
        } catch (e) {
          node.el.classList.remove('active');
          node.el.classList.add('error');
          console.error("Node error:", e);
          break;
        }
      }
    }

    async function runNode(node, context) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          const type = node.type;
          if (type === 'Script Writer') {
            context.output = `<html><head><title>Hello BossAI</title></head><body><h1>Welcome</h1></body></html>`;
          } else if (type === 'HTML Extract') {
            try {
              const parser = new DOMParser();
              const doc = parser.parseFromString(context.output, 'text/html');
              const title = doc.querySelector('title')?.innerText || 'No title found';
              context.output = title;
            } catch (e) {
              reject(e);
              return;
            }
          } else if (type === 'Logger') {
            alert("Logger Output: " + context.output);
            console.log("Logger:", context.output);
          }
          resolve();
        }, 600);
      });
    }

    function topologicalSort(nodes, edges) {
      const adj = {}, inDegree = {}, result = [];
      nodes.forEach(n => { adj[n] = []; inDegree[n] = 0; });
      edges.forEach(([from, to]) => {
        adj[from].push(to);
        inDegree[to]++;
      });
      const queue = nodes.filter(n => inDegree[n] === 0);
      while (queue.length) {
        const node = queue.shift();
        result.push(node);
        adj[node].forEach(neigh => {
          inDegree[neigh]--;
          if (inDegree[neigh] === 0) queue.push(neigh);
        });
      }
      return result;
    }
  </script>
</body>
</html>
