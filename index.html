<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Boss AI - Visual Automation</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(to right, #000000, #0a0a2a);
      color: #00bfff;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 10px 20px;
      background: #111;
      font-size: 20px;
      color: #00bfff;
      text-shadow: 0 0 8px #00bfff;
    }
    #toolbar {
      display: flex;
      gap: 10px;
      padding: 10px;
      background: #0d0d0d;
    }
    button {
      font-family: 'Orbitron', sans-serif;
      padding: 6px 14px;
      font-size: 14px;
      background: #001f33;
      color: #00bfff;
      border: 1px solid #00bfff;
      cursor: pointer;
      text-shadow: 0 0 4px #00bfff;
    }
    #canvas {
      flex: 1;
      position: relative;
      background: #050b13;
      overflow: hidden;
    }
    .node {
      position: absolute;
      width: 160px;
      padding: 10px;
      background: #0c0c0c;
      border: 1px solid #00bfff;
      color: #00bfff;
      text-shadow: 0 0 4px #00bfff;
      cursor: move;
    }
    .line {
      position: absolute;
      background: #00bfff;
      height: 2px;
      transform-origin: 0 0;
    }
    #log {
      height: 100px;
      background: #0a0a0a;
      color: #00ffcc;
      overflow-y: auto;
      font-size: 12px;
      padding: 8px;
      border-top: 1px solid #00bfff;
    }
    .glow {
      text-shadow: 0 0 5px #00bfff, 0 0 10px #00bfff;
    }
    .highlight {
      background-color: #003344 !important;
    }
  </style>
</head>
<body>
  <header class="glow">Boss AI ‚Äì Visual Workflow Engine</header>
  <div id="toolbar">
    <button onclick="addNode('Script Writer')">+ Script Writer</button>
    <button onclick="addNode('Voiceover')">+ Voiceover</button>
    <button onclick="addNode('Logger')">+ Logger</button>
    <button onclick="runWorkflow()">‚ñ∂Ô∏è Run</button>
    <button onclick="exportWorkflow()">üì§ Export</button>
    <button onclick="importWorkflow()">üì• Import</button>
    <button onclick="clearCanvas()">üóë Clear</button>
  </div>
  <div id="canvas"></div>
  <div id="log"></div>

  <script>
    const canvas = document.getElementById("canvas");
    const log = document.getElementById("log");
    let nodes = [];
    let connections = [];

    function logMsg(msg) {
      const line = document.createElement("div");
      line.textContent = msg;
      log.appendChild(line);
      log.scrollTop = log.scrollHeight;
    }

    function addNode(type, x = 100, y = 100) {
      const div = document.createElement("div");
      div.className = "node";
      div.textContent = type;
      div.style.left = x + "px";
      div.style.top = y + "px";

      const node = { id: Date.now() + Math.random(), type, div, x, y, outputs: [], run: async function(context) {
        div.classList.add("highlight");
        logMsg(`Running ${type}`);
        await new Promise(r => setTimeout(r, 1000));
        let output = "";
        if (type === "Script Writer") {
          output = "This is AI-generated text.";
        } else if (type === "Voiceover") {
          output = `üîä Speaking: ${context.lastOutput || "No input"}`;
        } else if (type === "Logger") {
          logMsg(`üìù Logger: ${context.lastOutput}`);
        }
        context.lastOutput = output;
        div.classList.remove("highlight");
      }};

      div.onmousedown = e => {
        let offsetX = e.offsetX;
        let offsetY = e.offsetY;
        function move(e2) {
          div.style.left = (e2.pageX - offsetX) + "px";
          div.style.top = (e2.pageY - offsetY) + "px";
        }
        function up() {
          document.removeEventListener("mousemove", move);
          document.removeEventListener("mouseup", up);
        }
        document.addEventListener("mousemove", move);
        document.addEventListener("mouseup", up);
      };

      div.ondblclick = () => {
        const outNode = prompt("Connect to node ID:");
        const target = nodes.find(n => n.id == outNode);
        if (target) {
          node.outputs.push(target.id);
          drawLine(node.div, target.div);
          connections.push({ from: node.id, to: target.id });
        }
      };

      canvas.appendChild(div);
      nodes.push(node);
    }

    function drawLine(fromDiv, toDiv) {
      const line = document.createElement("div");
      line.className = "line";
      canvas.appendChild(line);
      const rect1 = fromDiv.getBoundingClientRect();
      const rect2 = toDiv.getBoundingClientRect();
      const x1 = rect1.left + rect1.width / 2;
      const y1 = rect1.top + rect1.height / 2;
      const x2 = rect2.left + rect2.width / 2;
      const y2 = rect2.top + rect2.height / 2;
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const length = Math.hypot(x2 - x1, y2 - y1);
      line.style.left = x1 + "px";
      line.style.top = y1 + "px";
      line.style.width = length + "px";
      line.style.transform = `rotate(${angle}rad)`;
    }

    async function runWorkflow() {
      logMsg("‚ñ∂Ô∏è Executing workflow...");
      const idToNode = Object.fromEntries(nodes.map(n => [n.id, n]));
      const visited = new Set();
      const context = {};

      async function visit(nodeId) {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        const node = idToNode[nodeId];
        await node.run(context);
        for (let outId of node.outputs) {
          await visit(outId);
        }
      }

      // Run all start nodes
      for (let node of nodes) {
        if (!connections.some(c => c.to === node.id)) {
          await visit(node.id);
        }
      }

      logMsg("‚úÖ Workflow complete.");
    }

    function exportWorkflow() {
      const data = {
        nodes: nodes.map(n => ({
          id: n.id,
          type: n.type,
          x: parseInt(n.div.style.left),
          y: parseInt(n.div.style.top),
          outputs: n.outputs
        })),
        connections
      };
      navigator.clipboard.writeText(JSON.stringify(data)).then(() =>
        logMsg("üì§ Workflow copied to clipboard!")
      );
    }

    function importWorkflow() {
      const json = prompt("Paste workflow JSON:");
      if (!json) return;
      clearCanvas();
      try {
        const data = JSON.parse(json);
        for (let n of data.nodes) addNode(n.type, n.x, n.y);
        setTimeout(() => {
          for (let i = 0; i < data.connections.length; i++) {
            const c = data.connections[i];
            const from = nodes.find(n => n.id == c.from);
            const to = nodes.find(n => n.id == c.to);
            if (from && to) {
              from.outputs.push(to.id);
              drawLine(from.div, to.div);
              connections.push(c);
            }
          }
        }, 100);
      } catch (e) {
        logMsg("‚ùå Invalid JSON");
      }
    }

    function clearCanvas() {
      canvas.innerHTML = "";
      nodes = [];
      connections = [];
      logMsg("üßπ Canvas cleared");
    }
  </script>
</body>
</html>
