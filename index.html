<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Automation Canvas</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: flex;
            height: 100vh;
            background: linear-gradient(135deg, #000 0%, #1a1a1a 100%);
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #0099ff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
        }

        .header h1 {
            font-weight: 900;
            font-size: 24px;
            color: #0099ff;
            text-shadow: 0 0 10px rgba(0, 153, 255, 0.3);
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background: rgba(0, 153, 255, 0.1);
            border: 1px solid #0099ff;
            color: #0099ff;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 4px;
        }

        .btn:hover {
            background: rgba(0, 153, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 153, 255, 0.4);
        }

        .btn.primary {
            background: #0099ff;
            color: #000;
        }

        .btn.primary:hover {
            background: #0077cc;
            box-shadow: 0 0 20px rgba(0, 153, 255, 0.6);
        }

        .btn.danger {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .btn.danger:hover {
            background: rgba(255, 68, 68, 0.2);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.4);
        }

        .sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.9);
            border-right: 1px solid #0099ff;
            padding: 80px 20px 20px;
            overflow-y: auto;
        }

        .sidebar h2 {
            color: #0099ff;
            font-size: 16px;
            margin-bottom: 15px;
            text-shadow: 0 0 5px rgba(0, 153, 255, 0.3);
        }

        .node-type {
            background: rgba(0, 153, 255, 0.1);
            border: 1px solid #0099ff;
            padding: 12px;
            margin: 10px 0;
            cursor: grab;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .node-type:hover {
            background: rgba(0, 153, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 153, 255, 0.3);
        }

        .node-type:active {
            cursor: grabbing;
        }

        .node-type h3 {
            font-size: 14px;
            color: #fff;
            margin-bottom: 5px;
        }

        .node-type p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.4;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            margin-top: 60px;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background: 
                radial-gradient(circle at 25% 25%, rgba(0, 153, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(0, 153, 255, 0.05) 0%, transparent 50%);
            cursor: crosshair;
        }

        .canvas-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            min-width: 180px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0099ff;
            border-radius: 8px;
            padding: 15px;
            cursor: move;
            z-index: 10;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 153, 255, 0.1);
        }

        .node:hover {
            box-shadow: 0 6px 30px rgba(0, 153, 255, 0.2);
            border-color: #00bbff;
        }

        .node.executing {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .node.executed {
            border-color: #888;
            opacity: 0.8;
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .node-title {
            font-size: 14px;
            font-weight: 700;
            color: #0099ff;
            text-shadow: 0 0 5px rgba(0, 153, 255, 0.3);
        }

        .node-type-label {
            font-size: 10px;
            color: #888;
            background: rgba(0, 153, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #0099ff;
        }

        .node-content {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .node-ports {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 20px;
        }

        .port {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #0099ff;
            background: rgba(0, 153, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s;
        }

        .port.input {
            margin-left: -20px;
        }

        .port.output {
            margin-right: -20px;
            background: rgba(0, 153, 255, 0.3);
        }

        .port:hover {
            background: #0099ff;
            box-shadow: 0 0 10px rgba(0, 153, 255, 0.6);
        }

        .connection {
            stroke: #0099ff;
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 5px rgba(0, 153, 255, 0.3));
        }

        .connection.active {
            stroke: #00ff00;
            stroke-width: 3;
            filter: drop-shadow(0 0 10px rgba(0, 255, 0, 0.6));
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #000;
            border: 1px solid #0099ff;
            border-radius: 8px;
            padding: 30px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 10px 50px rgba(0, 153, 255, 0.3);
        }

        .modal h2 {
            color: #0099ff;
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: #0099ff;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: rgba(0, 153, 255, 0.1);
            border: 1px solid #0099ff;
            border-radius: 4px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
        }

        .form-group textarea {
            height: 120px;
            resize: vertical;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #00bbff;
            box-shadow: 0 0 10px rgba(0, 153, 255, 0.3);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .execution-log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #0099ff;
            border-radius: 8px;
            padding: 15px;
            font-size: 12px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .execution-log.active {
            display: block;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 4px;
        }

        .log-entry.info {
            background: rgba(0, 153, 255, 0.1);
            color: #0099ff;
        }

        .log-entry.success {
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
        }

        .log-entry.error {
            background: rgba(255, 68, 68, 0.1);
            color: #ff4444;
        }

        .status-indicator {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0099ff;
            border-radius: 4px;
            font-size: 12px;
            color: #0099ff;
            display: none;
        }

        .status-indicator.active {
            display: block;
        }

        .status-indicator.executing {
            border-color: #00ff00;
            color: #00ff00;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .drag-preview {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>Visual Automation Canvas</h1>
            <div class="header-controls">
                <button class="btn primary" onclick="runWorkflow()">â–¶ RUN</button>
                <button class="btn" onclick="exportWorkflow()">ðŸ“¤ EXPORT</button>
                <button class="btn" onclick="importWorkflow()">ðŸ“¥ IMPORT</button>
                <button class="btn danger" onclick="clearCanvas()">ðŸ—‘ CLEAR</button>
            </div>
        </div>

        <div class="sidebar">
            <h2>Node Types</h2>
            <div class="node-type" draggable="true" data-type="script">
                <h3>Script Writer</h3>
                <p>Generate scripts and content using AI prompts</p>
            </div>
            <div class="node-type" draggable="true" data-type="voiceover">
                <h3>Voiceover</h3>
                <p>Convert text to speech with voice settings</p>
            </div>
            <div class="node-type" draggable="true" data-type="logger">
                <h3>Logger</h3>
                <p>Log messages and data for debugging</p>
            </div>
            <div class="node-type" draggable="true" data-type="http">
                <h3>HTTP Request</h3>
                <p>Make API calls and web requests</p>
            </div>
            <div class="node-type" draggable="true" data-type="delay">
                <h3>Delay</h3>
                <p>Add time delays between operations</p>
            </div>
            <div class="node-type" draggable="true" data-type="conditional">
                <h3>Conditional</h3>
                <p>Branch workflow based on conditions</p>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas" id="canvas">
                <svg class="canvas-svg" id="canvas-svg"></svg>
            </div>
        </div>

        <div class="status-indicator" id="statusIndicator">Ready</div>
        
        <div class="execution-log" id="executionLog">
            <h3 style="color: #0099ff; margin-bottom: 10px;">Execution Log</h3>
            <div id="logContent"></div>
        </div>
    </div>

    <!-- Modal for editing nodes -->
    <div class="modal" id="editModal">
        <div class="modal-content">
            <h2>Edit Node</h2>
            <div class="form-group">
                <label for="nodeTitle">Node Title:</label>
                <input type="text" id="nodeTitle" placeholder="Enter node title">
            </div>
            <div class="form-group">
                <label for="nodeConfig">Configuration:</label>
                <textarea id="nodeConfig" placeholder="Enter configuration details..."></textarea>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeModal()">Cancel</button>
                <button class="btn primary" onclick="saveNode()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let isDragging = false;
        let draggedNode = null;
        let isConnecting = false;
        let connectionStart = null;
        let currentEditingNode = null;
        let executionState = 'idle';

        // Node type definitions
        const nodeTypes = {
            script: {
                title: 'Script Writer',
                defaultConfig: 'Write a creative script about...',
                execute: async function(config, input) {
                    log('info', `Executing Script Writer: ${config.substring(0, 50)}...`);
                    await delay(1000);
                    return `Generated script: ${config}`;
                }
            },
            voiceover: {
                title: 'Voiceover',
                defaultConfig: 'Voice: Natural, Speed: 1.0x',
                execute: async function(config, input) {
                    log('info', `Executing Voiceover: ${config}`);
                    await delay(1500);
                    return `Audio generated with settings: ${config}`;
                }
            },
            logger: {
                title: 'Logger',
                defaultConfig: 'Log level: INFO',
                execute: async function(config, input) {
                    log('info', `Logger: ${input || 'No input data'}`);
                    await delay(300);
                    return input;
                }
            },
            http: {
                title: 'HTTP Request',
                defaultConfig: 'GET https://api.example.com/data',
                execute: async function(config, input) {
                    log('info', `Making HTTP request: ${config}`);
                    await delay(2000);
                    return `HTTP response: ${config}`;
                }
            },
            delay: {
                title: 'Delay',
                defaultConfig: '2000ms',
                execute: async function(config, input) {
                    const ms = parseInt(config) || 2000;
                    log('info', `Waiting ${ms}ms...`);
                    await delay(ms);
                    return input;
                }
            },
            conditional: {
                title: 'Conditional',
                defaultConfig: 'if (input.length > 0) return true',
                execute: async function(config, input) {
                    log('info', `Evaluating condition: ${config}`);
                    await delay(500);
                    return input;
                }
            }
        };

        // Initialize canvas
        function initCanvas() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-svg');

            // Handle drag and drop from sidebar
            document.addEventListener('dragstart', handleDragStart);
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('drop', handleDrop);

            // Handle node interactions
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);

            // Handle connection drawing
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            updateCanvas();
        }

        // Drag and drop handlers
        function handleDragStart(e) {
            if (e.target.classList.contains('node-type')) {
                e.dataTransfer.setData('nodeType', e.target.dataset.type);
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('nodeType');
            if (nodeType) {
                const rect = document.getElementById('canvas').getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createNode(nodeType, x, y);
            }
        }

        // Create new node
        function createNode(type, x, y) {
            const nodeType = nodeTypes[type];
            const node = {
                id: `node_${nodeIdCounter++}`,
                type: type,
                title: nodeType.title,
                config: nodeType.defaultConfig,
                x: x,
                y: y,
                executed: false
            };
            nodes.push(node);
            updateCanvas();
            return node;
        }

        // Canvas interaction handlers
        function handleCanvasMouseDown(e) {
            const node = getNodeAtPosition(e.clientX, e.clientY);
            if (node) {
                if (isConnecting) {
                    if (connectionStart && connectionStart.id !== node.id) {
                        createConnection(connectionStart.id, node.id);
                        isConnecting = false;
                        connectionStart = null;
                        updateCanvas();
                    }
                } else {
                    isDragging = true;
                    draggedNode = node;
                    const rect = document.getElementById('canvas').getBoundingClientRect();
                    draggedNode.offsetX = e.clientX - rect.left - node.x;
                    draggedNode.offsetY = e.clientY - rect.top - node.y;
                }
            }
        }

        function handleCanvasMouseMove(e) {
            if (isDragging && draggedNode) {
                const rect = document.getElementById('canvas').getBoundingClientRect();
                draggedNode.x = e.clientX - rect.left - draggedNode.offsetX;
                draggedNode.y = e.clientY - rect.top - draggedNode.offsetY;
                updateCanvas();
            }
        }

        function handleCanvasMouseUp(e) {
            isDragging = false;
            draggedNode = null;
        }

        function handleCanvasDoubleClick(e) {
            const node = getNodeAtPosition(e.clientX, e.clientY);
            if (node) {
                openEditModal(node);
            }
        }

        // Connection handling
        function handleKeyDown(e) {
            if (e.ctrlKey && !isConnecting) {
                const node = getNodeAtPosition(e.clientX, e.clientY);
                if (node) {
                    isConnecting = true;
                    connectionStart = node;
                    document.getElementById('canvas').style.cursor = 'crosshair';
                }
            }
        }

        function handleKeyUp(e) {
            if (!e.ctrlKey && isConnecting) {
                isConnecting = false;
                connectionStart = null;
                document.getElementById('canvas').style.cursor = 'default';
            }
        }

        // Utility functions
        function getNodeAtPosition(clientX, clientY) {
            const rect = document.getElementById('canvas').getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            return nodes.find(node => 
                x >= node.x && x <= node.x + 180 &&
                y >= node.y && y <= node.y + 120
            );
        }

        function createConnection(fromId, toId) {
            if (!connections.find(conn => conn.from === fromId && conn.to === toId)) {
                connections.push({ from: fromId, to: toId });
            }
        }

        // Modal functions
        function openEditModal(node) {
            currentEditingNode = node;
            document.getElementById('nodeTitle').value = node.title;
            document.getElementById('nodeConfig').value = node.config;
            document.getElementById('editModal').style.display = 'flex';
        }

        function closeModal() {
            document.getElementById('editModal').style.display = 'none';
            currentEditingNode = null;
        }

        function saveNode() {
            if (currentEditingNode) {
                currentEditingNode.title = document.getElementById('nodeTitle').value;
                currentEditingNode.config = document.getElementById('nodeConfig').value;
                updateCanvas();
                closeModal();
            }
        }

        // Canvas rendering
        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-svg');
            
            // Clear existing nodes
            const existingNodes = canvas.querySelectorAll('.node');
            existingNodes.forEach(node => node.remove());
            
            // Render nodes
            nodes.forEach(node => {
                const nodeElement = document.createElement('div');
                nodeElement.className = `node ${node.executed ? 'executed' : ''}`;
                nodeElement.style.left = node.x + 'px';
                nodeElement.style.top = node.y + 'px';
                nodeElement.innerHTML = `
                    <div class="node-header">
                        <div class="node-title">${node.title}</div>
                        <div class="node-type-label">${node.type}</div>
                    </div>
                    <div class="node-content">${node.config}</div>
                    <div class="node-ports">
                        <div class="port input"></div>
                        <div class="port output"></div>
                    </div>
                `;
                canvas.appendChild(nodeElement);
            });
            
            // Render connections
            svg.innerHTML = '';
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                if (fromNode && toNode) {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const fromX = fromNode.x + 180;
                    const fromY = fromNode.y + 60;
                    const toX = toNode.x;
                    const toY = toNode.y + 60;
                    
                    const midX = (fromX + toX) / 2;
                    const d = `M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`;
                    
                    path.setAttribute('d', d);
                    path.setAttribute('class', 'connection');
                    svg.appendChild(path);
                }
            });
        }

        // Workflow execution
        async function runWorkflow() {
            if (executionState === 'executing') return;
            
            executionState = 'executing';
            updateStatus('Executing workflow...', 'executing');
            showExecutionLog();
            
            // Reset execution state
            nodes.forEach(node => {
                node.executed = false;
                node.result = null;
            });
            
            clearLog();
            log('info', 'Starting workflow execution...');
            
            try {
                // Find starting nodes (nodes with no incoming connections)
                const startNodes = nodes.filter(node => 
                    !connections.some(conn => conn.to === node.id)
                );
                
                if (startNodes.length === 0) {
                    log('error', 'No starting nodes found. Add nodes without input connections.');
                    return;
                }
                
                // Execute nodes in topological order
                const executedNodes = new Set();
                const executing = [];
                
                for (const startNode of startNodes) {
                    executing.push(executeNodeChain(startNode, executedNodes));
                }
                
                await Promise.all(executing);
                
                log('success', 'Workflow execution completed successfully!');
                
            } catch (error) {
                log('error', `Workflow execution failed: ${error.message}`);
            } finally {
                executionState = 'idle';
                updateStatus('Ready', 'idle');
                updateCanvas();
            }
        }

        async function executeNodeChain(node, executedNodes) {
            if (executedNodes.has(node.id)) return node.result;
            
            // Wait for all input nodes to complete
            const inputConnections = connections.filter(conn => conn.to === node.id);
            const inputResults = [];
            
            for (const conn of inputConnections) {
                const inputNode = nodes.find(n => n.id === conn.from);
                if (inputNode) {
                    const result = await executeNodeChain(inputNode, executedNodes);
                    inputResults.push(result);
                }
            }
            
            // Execute current node
            const nodeElement = document.querySelector(`.node:nth-child(${nodes.indexOf(node) + 1})`);
            if (nodeElement) {
                nodeElement.classList.add('executing');
            }
            
            const nodeType = nodeTypes[node.type];
            const inputData = inputResults.length > 0 ? inputResults.join('\n') : null;
            
            try {
                node.result = await nodeType.execute(node.config, inputData);
                node.executed = true;
                executedNodes.add(node.id);
                
                if (nodeElement) {
                    nodeElement.classList.remove('executing');
                    nodeElement.classList.add('executed');
                }
                
                log('success', `${node.title} completed: ${node.result.substring(0, 100)}...`);
                
            } catch (error) {
                log('error', `${node.title} failed: ${error.message}`);
                throw error;
            }
            
            return node.result;
        }

        // Export/Import functions
        function exportWorkflow() {
            const workflow = {
                nodes: nodes,
                connections: connections
            };
            const jsonStr = JSON.stringify(workflow, null, 2);
            
            navigator.clipboard.writeText(jsonStr).then(() => {
                log('success', 'Workflow exported to clipboard!');
                showExecutionLog();
            }).catch(() => {
                // Fallback for browsers that don't support clipboard API
                const textarea = document.createElement('textarea');
                textarea.value = jsonStr;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                log('success', 'Workflow exported to clipboard!');
                showExecutionLog();
            });
        }

        function importWorkflow() {
            const jsonStr = prompt('Paste your workflow JSON:');
            if (!jsonStr) return;
            
            try {
                const workflow = JSON.parse(jsonStr);
                nodes = workflow.nodes || [];
                connections = workflow.connections || [];
                
                // Update counter to avoid ID conflicts
                nodeIdCounter = Math.max(...nodes.map(n => parseInt(n.id.split('_')[1]) || 0), 0) + 1;
                
                updateCanvas();
                log('success', 'Workflow imported successfully!');
                showExecutionLog();
                
            } catch (error) {
                log('error', 'Failed to import workflow: Invalid JSON');
                showExecutionLog();
            }
        }

        function clearCanvas() {
            if (confirm('Are you sure you want to clear the canvas?')) {
                nodes = [];
                connections = [];
                nodeIdCounter = 0;
                updateCanvas();
                clearLog();
                log('info', 'Canvas cleared');
                showExecutionLog();
            }
        }

        // Logging functions
        function log(type, message) {
            const logContent = document.getElementById('logContent');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContent').innerHTML = '';
        }

        function showExecutionLog() {
            document.getElementById('executionLog').classList.add('active');
            setTimeout(() => {
                document.getElementById('executionLog').classList.remove('active');
            }, 5000);
        }

        // Status functions
        function updateStatus(message, state) {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = message;
            indicator.className = `status-indicator active ${state}`;
            
            if (state === 'idle') {
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 2000);
            }
        }

        // Utility function for delays
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Close modal on outside click
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('editModal');
            if (e.target === modal) {
                closeModal();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
            if (e.ctrlKey && e.key === 'Enter') {
                runWorkflow();
            }
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                exportWorkflow();
            }
        });

        // Initialize the application
        window.addEventListener('load', () => {
            initCanvas();
            log('info', 'Visual Automation Canvas initialized');
            updateStatus('Ready', 'idle');
        });
    </script>
</body>
</html>
